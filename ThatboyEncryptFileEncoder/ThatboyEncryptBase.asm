; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28314.0 

	TITLE	e:\visual studio application\????????????\thatboyencryptfileencoder\thatboyencryptbase.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?write@Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z ; thatboy::Chunk::write
PUBLIC	?read@Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z ; thatboy::Chunk::read
PUBLIC	?checkCrcCode@Chunk@thatboy@@UBE_NE@Z		; thatboy::Chunk::checkCrcCode
PUBLIC	?doFigure@Chunk@thatboy@@UAEXE@Z		; thatboy::Chunk::doFigure
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
;	COMDAT ?doFigure@Chunk@thatboy@@UAEXE@Z
_TEXT	SEGMENT
_crc$ = -1056						; size = 1048
__$ArrayPad$ = -4					; size = 4
_crcType$ = 8						; size = 1
?doFigure@Chunk@thatboy@@UAEXE@Z PROC			; thatboy::Chunk::doFigure, COMDAT
; _this$ = ecx

; 22   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 1060				; 00000424H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+1060], eax
	push	ebx
	push	esi
	push	edi

; 23   : 	Chunk::dataLength = 0;
; 24   : 	Chunk::typeCode = makeDWORD('T', 'E', 'N', 'D');
; 25   : 	CRC32 crc = CRC32(CRC32::CRC32_TYPE(crcType));

	push	DWORD PTR _crcType$[ebp]
	mov	edi, ecx
	lea	ecx, DWORD PTR _crc$[esp+1076]
	mov	DWORD PTR [edi+4], 0
	mov	DWORD PTR [edi+8], 1145980244		; 444e4554H
	call	??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z ; thatboy::CRC32::CRC32
	mov	ebx, DWORD PTR _crc$[esp+2112]
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h

; 73   :     for (offset = 0; offset < nBytes; offset++)

	xor	esi, esi
	mov	eax, DWORD PTR _crc$[esp+1076]
	add	ebx, -8					; fffffff8H
	npad	7
$LL14@doFigure:

; 74   :     {
; 75   :         byte = (remainder >> (m_width - 8)) ^ message[offset];

	mov	edx, eax
	mov	ecx, ebx
	shr	edx, cl
	movzx	ecx, BYTE PTR [edi+esi+8]
	inc	esi
	movzx	edx, dl
	xor	edx, ecx

; 76   :         remainder = crcTable[byte] ^ (remainder << 8);

	shl	eax, 8
	xor	eax, DWORD PTR _crc$[esp+edx*4+1088]
	cmp	esi, 4
	jb	SHORT $LL14@doFigure

; 77   :     }
; 78   :     /* The final remainder is the CRC result. */
; 79   :     return (remainder ^ m_final_xor_value);

	mov	ecx, DWORD PTR _crc$[esp+1080]
	xor	ecx, eax
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp

; 26   : 	Chunk::crcCode = crc.crcCompute((BYTE_CPTR)&typeCode, dataLength + sizeof(DWORD));

	mov	DWORD PTR [edi+12], ecx

; 27   : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+1072]
	pop	edi
	pop	esi
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?doFigure@Chunk@thatboy@@UAEXE@Z ENDP			; thatboy::Chunk::doFigure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
;	COMDAT ?checkCrcCode@Chunk@thatboy@@UBE_NE@Z
_TEXT	SEGMENT
_NChunk$ = -1072					; size = 16
_crc$1 = -1056						; size = 1048
__$ArrayPad$ = -4					; size = 4
_crcEncodeType$ = 8					; size = 1
?checkCrcCode@Chunk@thatboy@@UBE_NE@Z PROC		; thatboy::Chunk::checkCrcCode, COMDAT
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 1076				; 00000434H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+1076], eax
	push	ebx
	mov	ebx, DWORD PTR [ecx+12]

; 25   : 	CRC32 crc = CRC32(CRC32::CRC32_TYPE(crcType));

	lea	ecx, DWORD PTR _crc$1[esp+1080]

; 31   : {

	push	esi
	push	edi

; 25   : 	CRC32 crc = CRC32(CRC32::CRC32_TYPE(crcType));

	push	DWORD PTR _crcEncodeType$[ebp]
	mov	DWORD PTR _NChunk$[esp+1092], OFFSET ??_7Chunk@thatboy@@6B@
	mov	DWORD PTR _NChunk$[esp+1104], ebx

; 23   : 	Chunk::dataLength = 0;

	mov	DWORD PTR _NChunk$[esp+1096], 0

; 24   : 	Chunk::typeCode = makeDWORD('T', 'E', 'N', 'D');

	mov	DWORD PTR _NChunk$[esp+1100], 1145980244 ; 444e4554H

; 25   : 	CRC32 crc = CRC32(CRC32::CRC32_TYPE(crcType));

	call	??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z ; thatboy::CRC32::CRC32
	mov	edi, DWORD PTR _crc$1[esp+2128]

; 23   : 	Chunk::dataLength = 0;

	xor	esi, esi
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h

; 71   :     TYPE remainder = m_initial_remainder;

	mov	eax, DWORD PTR _crc$1[esp+1092]
	add	edi, -8					; fffffff8H
$LL18@checkCrcCo:

; 72   :     /* Divide the message by the polynomial, a byte at a time. */
; 73   :     for (offset = 0; offset < nBytes; offset++)
; 74   :     {
; 75   :         byte = (remainder >> (m_width - 8)) ^ message[offset];

	mov	edx, eax
	mov	ecx, edi
	shr	edx, cl
	movzx	ecx, BYTE PTR _NChunk$[esp+esi+1096]
	inc	esi
	movzx	edx, dl
	xor	edx, ecx

; 76   :         remainder = crcTable[byte] ^ (remainder << 8);

	shl	eax, 8
	xor	eax, DWORD PTR _crc$1[esp+edx*4+1104]
	cmp	esi, 4
	jb	SHORT $LL18@checkCrcCo

; 77   :     }
; 78   :     /* The final remainder is the CRC result. */
; 79   :     return (remainder ^ m_final_xor_value);

	mov	ecx, DWORD PTR _crc$1[esp+1096]
	xor	ecx, eax
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp

; 34   : 	return NChunk.crcCode == crcCode;

	cmp	ecx, ebx

; 35   : }

	mov	ecx, DWORD PTR __$ArrayPad$[esp+1088]
	pop	edi
	pop	esi
	sete	al
	pop	ebx
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?checkCrcCode@Chunk@thatboy@@UBE_NE@Z ENDP		; thatboy::Chunk::checkCrcCode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
;	COMDAT ?read@Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z
_TEXT	SEGMENT
_is$ = 8						; size = 4
?read@Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z PROC ; thatboy::Chunk::read, COMDAT
; _this$ = ecx

; 14   : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	esi

; 15   : 	is.read((LPSTR)&dataLength, sizeof(dataLength));

	mov	esi, DWORD PTR _is$[ebp]
	push	edi
	mov	edi, ecx
	mov	ecx, esi
	push	0
	push	4
	lea	eax, DWORD PTR [edi+4]
	push	eax
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 16   : 	is.read((LPSTR)&typeCode, sizeof(typeCode));

	push	0
	push	4
	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 17   : 	is.read((LPSTR)&crcCode, sizeof(crcCode));

	push	0
	push	4
	lea	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV12@PAD_J@Z

; 18   : 	return is;
; 19   : }

	pop	edi
	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?read@Chunk@thatboy@@UAEAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV34@@Z ENDP ; thatboy::Chunk::read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\ThatboyEncryptBase.cpp
;	COMDAT ?write@Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z
_TEXT	SEGMENT
_os$ = 8						; size = 4
?write@Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z PROC ; thatboy::Chunk::write, COMDAT
; _this$ = ecx

; 6    : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	esi

; 7    : 	os.write((LPCSTR)&dataLength, sizeof(dataLength));

	mov	esi, DWORD PTR _os$[ebp]
	push	edi
	mov	edi, ecx
	mov	ecx, esi
	push	0
	push	4
	lea	eax, DWORD PTR [edi+4]
	push	eax
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z

; 8    : 	os.write((LPCSTR)&typeCode, sizeof(typeCode));

	push	0
	push	4
	lea	ecx, DWORD PTR [edi+8]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z

; 9    : 	os.write((LPCSTR)&crcCode, sizeof(crcCode));

	push	0
	push	4
	lea	ecx, DWORD PTR [edi+12]
	push	ecx
	mov	ecx, esi
	call	DWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@PBD_J@Z

; 10   : 	return os;
; 11   : }

	pop	edi
	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?write@Chunk@thatboy@@UBEAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV34@@Z ENDP ; thatboy::Chunk::write
_TEXT	ENDS
END
