; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28314.0 

	TITLE	e:\visual studio application\????????????\thatboyencryptfileencoder\crc.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	?crcInit@?$CRC@I@thatboy@@IAEXXZ		; thatboy::CRC<unsigned int>::crcInit
PUBLIC	??0?$CRC@I@thatboy@@QAE@XZ			; thatboy::CRC<unsigned int>::CRC<unsigned int>
PUBLIC	??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z	; thatboy::CRC32::CRC32
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.cpp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.cpp
;	COMDAT ??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z
_TEXT	SEGMENT
_type$ = 8						; size = 1
??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z PROC		; thatboy::CRC32::CRC32, COMDAT
; _this$ = ecx

; 279  : {

	push	ebp
	mov	ebp, esp
	mov	eax, ecx

; 280  :     switch (type)

	movzx	ecx, BYTE PTR _type$[ebp]
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h

; 40   :     m_width = 8 * sizeof(TYPE);

	mov	DWORD PTR [eax+1040], 32		; 00000020H

; 41   :     m_topbit = 1 << (m_width - 1);

	mov	DWORD PTR [eax+1044], -2147483648	; 80000000H
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.cpp

; 280  :     switch (type)

	cmp	ecx, 15					; 0000000fH
	ja	SHORT $LN12@CRC32
	movzx	ecx, BYTE PTR $LN58@CRC32[ecx]
	jmp	DWORD PTR $LN59@CRC32[ecx*4]
$LN5@CRC32:

; 281  :     {
; 282  :     case CRC32_TYPE::eADCCP:
; 283  :     case CRC32_TYPE::ePKZIP:
; 284  :     case CRC32_TYPE::eCRC32:
; 285  :     case CRC32_TYPE::eBZIP2:
; 286  :     case CRC32_TYPE::eAAL5:
; 287  :     case CRC32_TYPE::eDECT_B:
; 288  :     case CRC32_TYPE::eB_CRC32:
; 289  :         m_polynomial = 0x04c11db7;
; 290  :         m_initial_remainder = 0xFFFFFFFF;
; 291  :         m_final_xor_value = 0xFFFFFFFF;
; 292  :         break;
; 293  :     case CRC32_TYPE::eAUTOSAR:
; 294  :         m_polynomial = 0xf4acfb13;

	mov	DWORD PTR [eax], -189990125		; f4acfb13H

; 295  :         m_initial_remainder = 0xFFFFFFFF;
; 296  :         m_final_xor_value = 0xFFFFFFFF;
; 297  :         break;

	jmp	SHORT $LN60@CRC32
$LN6@CRC32:

; 298  :     case CRC32_TYPE::eCRC32C:
; 299  :         m_polynomial = 0x1edc6f41;

	mov	DWORD PTR [eax], 517762881		; 1edc6f41H

; 300  :         m_initial_remainder = 0xFFFFFFFF;
; 301  :         m_final_xor_value = 0xFFFFFFFF;
; 302  :         break;

	jmp	SHORT $LN60@CRC32
$LN7@CRC32:

; 303  :     case CRC32_TYPE::eCRC32D:
; 304  :         m_polynomial = 0xa833982b;

	mov	DWORD PTR [eax], -1473013717		; a833982bH

; 305  :         m_initial_remainder = 0xFFFFFFFF;
; 306  :         m_final_xor_value = 0xFFFFFFFF;
; 307  :         break;

	jmp	SHORT $LN60@CRC32
$LN8@CRC32:

; 308  :     case CRC32_TYPE::eMPEG2:
; 309  :     case CRC32_TYPE::eJAMCRC:
; 310  :         m_polynomial = 0x04c11db7;

	mov	DWORD PTR [eax], 79764919		; 04c11db7H

; 311  :         m_initial_remainder = 0xFFFFFFFF;
; 312  :         m_final_xor_value = 0x00000000;

	mov	DWORD PTR [eax+8], 0

; 313  :         break;

	jmp	SHORT $LN61@CRC32
$LN9@CRC32:

; 314  :     case CRC32_TYPE::ePOSIX:
; 315  :     case CRC32_TYPE::eCKSUM:
; 316  :         m_polynomial = 0x04c11db7;

	mov	DWORD PTR [eax], 79764919		; 04c11db7H

; 317  :         m_initial_remainder = 0x00000000;

	mov	DWORD PTR [eax+4], 0

; 318  :         m_final_xor_value = 0xFFFFFFFF;

	mov	DWORD PTR [eax+8], -1

; 319  :         break;

	jmp	SHORT $LN2@CRC32
$LN10@CRC32:

; 320  :     case CRC32_TYPE::eCRC32Q:
; 321  :         m_polynomial = 0x814141ab;

	mov	DWORD PTR [eax], -2126429781		; 814141abH

; 322  :         m_initial_remainder = 0x00000000;

	mov	DWORD PTR [eax+4], 0

; 323  :         m_final_xor_value = 0x00000000;

	mov	DWORD PTR [eax+8], 0

; 324  :         break;

	jmp	SHORT $LN2@CRC32
$LN11@CRC32:

; 325  :     case CRC32_TYPE::eXFER:
; 326  :         m_polynomial = 0x000000af;

	mov	DWORD PTR [eax], 175			; 000000afH

; 327  :         m_initial_remainder = 0x00000000;

	mov	DWORD PTR [eax+4], 0

; 328  :         m_final_xor_value = 0x00000000;

	mov	DWORD PTR [eax+8], 0

; 329  :         break;

	jmp	SHORT $LN2@CRC32
$LN12@CRC32:

; 330  :     default:
; 331  :         m_polynomial = 0x04C11DB7;

	mov	DWORD PTR [eax], 79764919		; 04c11db7H
$LN60@CRC32:

; 12   :     for (dividend = 0; dividend < 256; dividend++)

	mov	DWORD PTR [eax+8], -1
$LN61@CRC32:
	mov	DWORD PTR [eax+4], -1
$LN2@CRC32:
	push	ebx
	push	esi
	push	edi
	xor	edi, edi
	lea	ebx, DWORD PTR [eax+16]
$LL19@CRC32:

; 13   :     {
; 14   :         /* 初始化其余部分。  */
; 15   :         remainder = dividend << (m_width - 8);

	mov	ecx, DWORD PTR [eax+1040]
	mov	edx, edi
	sub	ecx, 8
	shl	edx, cl

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	mov	ecx, DWORD PTR [eax+1044]
	lea	esi, DWORD PTR [edx+edx]
	test	ecx, edx
	je	SHORT $LN23@CRC32

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	edx, DWORD PTR [eax]
	xor	edx, esi

; 23   :             }

	jmp	SHORT $LN20@CRC32
$LN23@CRC32:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	edx, esi
$LN20@CRC32:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [edx+edx]
	test	ecx, edx
	je	SHORT $LN37@CRC32

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	edx, DWORD PTR [eax]
	xor	edx, esi

; 23   :             }

	jmp	SHORT $LN38@CRC32
$LN37@CRC32:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	edx, esi
$LN38@CRC32:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [edx+edx]
	test	ecx, edx
	je	SHORT $LN40@CRC32

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	edx, DWORD PTR [eax]
	xor	edx, esi

; 23   :             }

	jmp	SHORT $LN41@CRC32
$LN40@CRC32:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	edx, esi
$LN41@CRC32:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [edx+edx]
	test	ecx, edx
	je	SHORT $LN43@CRC32

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	edx, DWORD PTR [eax]
	xor	edx, esi

; 23   :             }

	jmp	SHORT $LN44@CRC32
$LN43@CRC32:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	edx, esi
$LN44@CRC32:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [edx+edx]
	test	ecx, edx
	je	SHORT $LN46@CRC32

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	edx, DWORD PTR [eax]
	xor	edx, esi

; 23   :             }

	jmp	SHORT $LN47@CRC32
$LN46@CRC32:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	edx, esi
$LN47@CRC32:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [edx+edx]
	test	ecx, edx
	je	SHORT $LN49@CRC32

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	edx, DWORD PTR [eax]
	xor	edx, esi

; 23   :             }

	jmp	SHORT $LN50@CRC32
$LN49@CRC32:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	edx, esi
$LN50@CRC32:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [edx+edx]
	test	ecx, edx
	je	SHORT $LN52@CRC32

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	edx, DWORD PTR [eax]
	xor	edx, esi

; 23   :             }

	jmp	SHORT $LN53@CRC32
$LN52@CRC32:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	edx, esi
$LN53@CRC32:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [edx+edx]
	test	ecx, edx
	je	SHORT $LN55@CRC32

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	ecx, DWORD PTR [eax]
	xor	ecx, esi

; 23   :             }

	jmp	SHORT $LN56@CRC32
$LN55@CRC32:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	ecx, esi
$LN56@CRC32:

; 27   :             }
; 28   :         }
; 29   :         /* 保存结果 */
; 30   :         crcTable[dividend] = remainder;

	mov	DWORD PTR [ebx], ecx
	inc	edi
	add	ebx, 4
	cmp	edi, 256				; 00000100H
	jb	$LL19@CRC32

; 332  :         m_initial_remainder = 0xFFFFFFFF;
; 333  :         m_final_xor_value = 0xFFFFFFFF;
; 334  :         break;
; 335  :     }
; 336  :     crcInit();
; 337  : }

	pop	edi
	pop	esi
	pop	ebx
	pop	ebp
	ret	4
	npad	3
$LN59@CRC32:
	DD	$LN12@CRC32
	DD	$LN5@CRC32
	DD	$LN6@CRC32
	DD	$LN7@CRC32
	DD	$LN8@CRC32
	DD	$LN9@CRC32
	DD	$LN10@CRC32
	DD	$LN11@CRC32
$LN58@CRC32:
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	0
	DB	1
	DB	2
	DB	3
	DB	4
	DB	5
	DB	5
	DB	6
	DB	4
	DB	7
??0CRC32@thatboy@@QAE@W4CRC32_TYPE@01@@Z ENDP		; thatboy::CRC32::CRC32
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.h
;	COMDAT ??0?$CRC@I@thatboy@@QAE@XZ
_TEXT	SEGMENT
??0?$CRC@I@thatboy@@QAE@XZ PROC				; thatboy::CRC<unsigned int>::CRC<unsigned int>, COMDAT
; _this$ = ecx

; 40   :     m_width = 8 * sizeof(TYPE);

	mov	DWORD PTR [ecx+1040], 32		; 00000020H

; 41   :     m_topbit = 1 << (m_width - 1);
; 42   : }

	mov	eax, ecx
	mov	DWORD PTR [ecx+1044], -2147483648	; 80000000H
	ret	0
??0?$CRC@I@thatboy@@QAE@XZ ENDP				; thatboy::CRC<unsigned int>::CRC<unsigned int>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File E:\Visual Studio Application\文件加密算法设计\ThatboyEncryptFileEncoder\CRC.cpp
;	COMDAT ?crcInit@?$CRC@I@thatboy@@IAEXXZ
_TEXT	SEGMENT
?crcInit@?$CRC@I@thatboy@@IAEXXZ PROC			; thatboy::CRC<unsigned int>::crcInit, COMDAT
; _this$ = ecx

; 7    : {

	push	ebx
	mov	edx, ecx
	push	esi
	push	edi

; 8    :     TYPE remainder;
; 9    :     TYPE dividend;
; 10   :     int bit;
; 11   :     /* 执行二进制长除法，一次一位。 */
; 12   :     for (dividend = 0; dividend < 256; dividend++)

	xor	edi, edi

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	ebx, DWORD PTR [edx+16]
	npad	6
$LL4@crcInit:

; 13   :     {
; 14   :         /* 初始化其余部分。  */
; 15   :         remainder = dividend << (m_width - 8);

	mov	ecx, DWORD PTR [edx+1040]
	mov	eax, edi
	sub	ecx, 8
	shl	eax, cl

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	mov	ecx, DWORD PTR [edx+1044]
	lea	esi, DWORD PTR [eax+eax]
	test	ecx, eax
	je	SHORT $LN8@crcInit

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	eax, DWORD PTR [edx]
	xor	eax, esi

; 23   :             }

	jmp	SHORT $LN5@crcInit
$LN8@crcInit:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	eax, esi
$LN5@crcInit:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [eax+eax]
	test	ecx, eax
	je	SHORT $LN22@crcInit

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	eax, DWORD PTR [edx]
	xor	eax, esi

; 23   :             }

	jmp	SHORT $LN23@crcInit
$LN22@crcInit:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	eax, esi
$LN23@crcInit:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [eax+eax]
	test	ecx, eax
	je	SHORT $LN25@crcInit

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	eax, DWORD PTR [edx]
	xor	eax, esi

; 23   :             }

	jmp	SHORT $LN26@crcInit
$LN25@crcInit:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	eax, esi
$LN26@crcInit:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [eax+eax]
	test	ecx, eax
	je	SHORT $LN28@crcInit

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	eax, DWORD PTR [edx]
	xor	eax, esi

; 23   :             }

	jmp	SHORT $LN29@crcInit
$LN28@crcInit:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	eax, esi
$LN29@crcInit:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [eax+eax]
	test	ecx, eax
	je	SHORT $LN31@crcInit

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	eax, DWORD PTR [edx]
	xor	eax, esi

; 23   :             }

	jmp	SHORT $LN32@crcInit
$LN31@crcInit:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	eax, esi
$LN32@crcInit:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [eax+eax]
	test	ecx, eax
	je	SHORT $LN34@crcInit

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	eax, DWORD PTR [edx]
	xor	eax, esi

; 23   :             }

	jmp	SHORT $LN35@crcInit
$LN34@crcInit:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	eax, esi
$LN35@crcInit:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [eax+eax]
	test	ecx, eax
	je	SHORT $LN37@crcInit

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	eax, DWORD PTR [edx]
	xor	eax, esi

; 23   :             }

	jmp	SHORT $LN38@crcInit
$LN37@crcInit:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	eax, esi
$LN38@crcInit:

; 16   :         /* 用多项式进行移位和异或运算。   */
; 17   :         for (bit = 0; bit < 8; bit++)
; 18   :         {
; 19   :             /* 尝试分割当前数据位。  */
; 20   :             if (remainder & m_topbit)

	lea	esi, DWORD PTR [eax+eax]
	test	ecx, eax
	je	SHORT $LN40@crcInit

; 21   :             {
; 22   :                 remainder = (remainder << 1) ^ m_polynomial;

	mov	eax, DWORD PTR [edx]
	xor	eax, esi

; 23   :             }

	jmp	SHORT $LN41@crcInit
$LN40@crcInit:

; 24   :             else
; 25   :             {
; 26   :                 remainder = remainder << 1;

	mov	eax, esi
$LN41@crcInit:

; 27   :             }
; 28   :         }
; 29   :         /* 保存结果 */
; 30   :         crcTable[dividend] = remainder;

	mov	DWORD PTR [ebx], eax
	inc	edi
	add	ebx, 4
	cmp	edi, 256				; 00000100H
	jb	$LL4@crcInit

; 31   :     }
; 32   : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?crcInit@?$CRC@I@thatboy@@IAEXXZ ENDP			; thatboy::CRC<unsigned int>::crcInit
_TEXT	ENDS
END
